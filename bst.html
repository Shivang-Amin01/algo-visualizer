<!-- bst.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Binary Search Tree Visualizer</title>
  <link rel="stylesheet" href="style.css">
  <style>
    #tree-container {
      display: flex;
      justify-content: center;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .node {
      display: inline-block;
      background-color: #4CAF50;
      color: white;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      text-align: center;
      line-height: 40px;
      margin: 10px;
      font-weight: bold;
      transition: transform 0.3s, background-color 0.3s;
    }

    .node.inserted {
      background-color: #ff9800;
      transform: scale(1.3);
    }

    .node.deleted {
      background-color: #f44336;
      opacity: 0.4;
    }
  </style>
</head>
<body>
  <h1>Binary Search Tree Visualizer</h1>

  <input type="number" id="valueInput" placeholder="Enter value" />
  <button onclick="insert()">Insert</button>
  <button onclick="remove()">Delete</button>

  <div id="tree-container"></div>

  <script>
    // === BST Node Class ===
    class Node {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
      }
    }

    // === BST Logic ===
    class BST {
      constructor() {
        this.root = null;
      }

      insert(value) {
        this.root = this._insertRec(this.root, value);
        renderTree();
        highlightNode(value, 'inserted');
      }

      _insertRec(node, value) {
        if (!node) return new Node(value);
        if (value < node.value) node.left = this._insertRec(node.left, value);
        else if (value > node.value) node.right = this._insertRec(node.right, value);
        return node;
      }

      delete(value) {
        this.root = this._deleteRec(this.root, value);
        renderTree();
      }

      _deleteRec(node, value) {
        if (!node) return null;

        if (value < node.value) node.left = this._deleteRec(node.left, value);
        else if (value > node.value) node.right = this._deleteRec(node.right, value);
        else {
          if (!node.left) return node.right;
          if (!node.right) return node.left;

          // Node with two children
          const minLargerNode = this._minValue(node.right);
          node.value = minLargerNode.value;
          node.right = this._deleteRec(node.right, minLargerNode.value);
        }
        return node;
      }

      _minValue(node) {
        let current = node;
        while (current.left) current = current.left;
        return current;
      }
    }

    // === Global Tree Instance ===
    const bst = new BST();

    function insert() {
      const value = parseInt(document.getElementById('valueInput').value);
      if (!isNaN(value)) bst.insert(value);
    }

    function remove() {
      const value = parseInt(document.getElementById('valueInput').value);
      if (!isNaN(value)) {
        highlightNode(value, 'deleted');
        setTimeout(() => bst.delete(value), 500);
      }
    }

    // === Render Tree ===
    function renderTree() {
      const container = document.getElementById('tree-container');
      container.innerHTML = '';
      renderNode(container, bst.root);
    }

    function renderNode(container, node) {
      if (!node) return;
      const div = document.createElement('div');
      div.className = 'node';
      div.textContent = node.value;
      div.id = `node-${node.value}`;
      container.appendChild(div);
      renderNode(container, node.left);
      renderNode(container, node.right);
    }

    // === Animation Highlight ===
    function highlightNode(value, className) {
      setTimeout(() => {
        const node = document.getElementById(`node-${value}`);
        if (node) {
          node.classList.add(className);
          setTimeout(() => node.classList.remove(className), 1000);
        }
      }, 100);
    }
  </script>
</body>
</html>
