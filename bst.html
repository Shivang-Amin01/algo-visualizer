<!-- bst.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Binary Search Tree Visualizer</title>
  <link rel="stylesheet" href="style.css">
  <style>
    #tree-container {
      position: relative;
      width: 100%;
      min-height: 600px;
      margin-top: 40px;
    }

    .node {
      position: absolute;
      background-color: #4CAF50;
      color: white;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      text-align: center;
      line-height: 40px;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .node.inserted {
      background-color: #ff9800;
      transform: scale(1.2);
    }

    .node.deleted {
      background-color: #f44336;
      opacity: 0.4;
    }

    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: visible;
      z-index: 0;
    }

    line {
      stroke: #555;
      stroke-width: 2;
    }
  </style>
</head>
<body>
  <h1>Binary Search Tree Visualizer</h1>
  <input type="number" id="valueInput" placeholder="Enter value">
  <button onclick="insert()">Insert</button>
  <button onclick="remove()">Delete</button>

  <div id="tree-container">
    <svg id="svg-lines"></svg>
  </div>

  <script>
    class Node {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.x = 0;
        this.y = 0;
      }
    }

    class BST {
      constructor() {
        this.root = null;
      }

      insert(value) {
        this.root = this._insertRec(this.root, value);
        updateTree();
        highlightNode(value, 'inserted');
      }

      _insertRec(node, value) {
        if (!node) return new Node(value);
        if (value < node.value) node.left = this._insertRec(node.left, value);
        else if (value > node.value) node.right = this._insertRec(node.right, value);
        return node;
      }

      delete(value) {
        this.root = this._deleteRec(this.root, value);
        updateTree();
      }

      _deleteRec(node, value) {
        if (!node) return null;
        if (value < node.value) node.left = this._deleteRec(node.left, value);
        else if (value > node.value) node.right = this._deleteRec(node.right, value);
        else {
          if (!node.left) return node.right;
          if (!node.right) return node.left;

          const minLargerNode = this._minValue(node.right);
          node.value = minLargerNode.value;
          node.right = this._deleteRec(node.right, minLargerNode.value);
        }
        return node;
      }

      _minValue(node) {
        while (node.left) node = node.left;
        return node;
      }
    }

    const bst = new BST();

    function insert() {
      const value = parseInt(document.getElementById('valueInput').value);
      if (!isNaN(value)) bst.insert(value);
    }

    function remove() {
      const value = parseInt(document.getElementById('valueInput').value);
      if (!isNaN(value)) {
        highlightNode(value, 'deleted');
        setTimeout(() => bst.delete(value), 500);
      }
    }

    function updateTree() {
      const container = document.getElementById('tree-container');
      const svg = document.getElementById('svg-lines');
      container.querySelectorAll('.node').forEach(n => n.remove());
      svg.innerHTML = '';

      const positions = [];
      assignCoordinates(bst.root, 0, 0, 500, positions);
      renderNodes(bst.root, container, svg, positions);
    }

    function assignCoordinates(node, depth, offsetX, width, positions) {
      if (!node) return;

      const x = offsetX + width / 2;
      const y = depth * 80 + 20;

      node.x = x;
      node.y = y;
      positions.push({ node, x, y });

      assignCoordinates(node.left, depth + 1, offsetX, width / 2, positions);
      assignCoordinates(node.right, depth + 1, offsetX + width / 2, width / 2, positions);
    }

    function renderNodes(node, container, svg, positions) {
      if (!node) return;

      if (node.left) {
        drawLine(svg, node.x, node.y, node.left.x, node.left.y);
      }
      if (node.right) {
        drawLine(svg, node.x, node.y, node.right.x, node.right.y);
      }

      const div = document.createElement('div');
      div.className = 'node';
      div.id = `node-${node.value}`;
      div.style.left = `${node.x}px`;
      div.style.top = `${node.y}px`;
      div.textContent = node.value;
      container.appendChild(div);

      renderNodes(node.left, container, svg, positions);
      renderNodes(node.right, container, svg, positions);
    }

    function drawLine(svg, x1, y1, x2, y2) {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1 + 20); // center of circle
      line.setAttribute('y1', y1 + 20);
      line.setAttribute('x2', x2 + 20);
      line.setAttribute('y2', y2 + 20);
      svg.appendChild(line);
    }

    function highlightNode(value, className) {
      setTimeout(() => {
        const node = document.getElementById(`node-${value}`);
        if (node) {
          node.classList.add(className);
          setTimeout(() => node.classList.remove(className), 1000);
        }
      }, 100);
    }
  </script>
</body>
</html>
